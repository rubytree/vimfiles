# #!/usr/bin/ruby
snippet #!
	#!/usr/bin/ruby

# New Block
snippet =b
	=begin rdoc
		${1}
	=end
snippet y
	:yields: ${1:arguments}
snippet rb
	#!/usr/bin/env ruby -wKU

snippet req
	require "${1}"${2}
snippet #
	# =>
snippet end
	__END__
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
snippet when
	when ${1:condition}
		${2}
snippet def
	def ${1:method_name}
		${2}
	end
snippet deft
	def test_${1:case_name}
		${2}
	end
snippet if
	if ${1:condition}
		${2}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
snippet elsif
	elsif ${1:condition}
		${2}
snippet unless
	unless ${1:condition}
		${2}
	end
snippet while
	while ${1:condition}
		${2}
	end
snippet until
	until ${1:condition}
		${2}
	end
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet cla class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end


	end
snippet cla class .. < ParentClass .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end


	end
snippet cla ClassName = Struct .. do .. end
	${1:`substitute(Filename(), '^.', '\u&', '')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end


	end
snippet cla class BlankSlate .. initialize .. end
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
snippet cla class << self .. end
	class << ${1:self}
		${2}
	end
# class .. < DelegateClass .. initialize .. end
snippet cla-
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end


	end
snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet mod module .. module_function .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module_function

		${2}
	end
snippet mod module .. ClassMethods .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module ClassMethods
			${2}
		end

		module InstanceMethods

		end

		def self.included(receiver)
			receiver.extend         ClassMethods
			receiver.send :include, InstanceMethods
		end
	end
# attr_reader
snippet r
	attr_reader :${1:attr_names}
# attr_writer
snippet w
	attr_writer :${1:attr_names}
# attr_accessor
snippet rw
	attr_accessor :${1:attr_names}
# include Enumerable
snippet Enum
	include Enumerable

	def each(&block)
		${1}
	end
# include Comparable
snippet Comp
	include Comparable

	def <=>(other)
		${1}
	end
# extend Forwardable
snippet Forw-
	extend Forwardable
# def self
snippet defs
	def self.${1:class_method_name}
		${2}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}
snippet defds
	def_delegators :${1:@del_obj}, :${2:del_methods}
snippet am
	alias_method :${1:new_name}, :${2:old_name}
snippet app
	if __FILE__ == $PROGRAM_NAME
		${1}
	end
# usage_if()
snippet usai
	if ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
# usage_unless()
snippet usau
	unless ARGV.${1}
		abort "Usage: #{$PROGRAM_NAME} ${2:ARGS_GO_HERE}"${3}
	end
snippet array
	Array.new(${1:10}) { |${2:i}| ${3} }
snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${3} }
snippet file File.foreach() { |line| .. }
	File.foreach(${1:"path/to/file"}) { |${2:line}| ${3} }
snippet file File.read()
	File.read(${1:"path/to/file"})${2}
snippet Dir Dir.global() { |file| .. }
	Dir.glob(${1:"dir/glob/*"}) { |${2:file}| ${3} }
snippet Dir Dir[".."]
	Dir[${1:"glob/**/*.rb"}]${2}
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if { |${1:e}| ${2} }
snippet fil
	fill(${1:range}) { |${2:i}| ${3} }
# flatten_once()
snippet flao
	inject(Array.new) { |${1:arr}, ${2:a}| $1.push(*$2)}${3}
snippet zip
	zip(${1:enums}) { |${2:row}| ${3} }
# downto(0) { |n| .. }
snippet dow
	downto(${1:0}) { |${2:n}| ${3} }
snippet ste
	step(${1:2}) { |${2:n}| ${3} }
snippet tim
	times { |${1:n}| ${2} }
snippet upt
	upto(${1:1.0/0.0}) { |${2:n}| ${3} }
snippet loo
	loop { ${1} }
snippet ea
	each { |${1:e}| ${2} }
snippet eab
	each_byte { |${1:byte}| ${2} }
snippet eac- each_char { |chr| .. }
	each_char { |${1:chr}| ${2} }
snippet eac- each_cons(..) { |group| .. }
	each_cons(${1:2}) { |${2:group}| ${3} }
snippet eai
	each_index { |${1:i}| ${2} }
snippet eak
	each_key { |${1:key}| ${2} }
snippet eal
	each_line { |${1:line}| ${2} }
snippet eap
	each_pair { |${1:name}, ${2:val}| ${3} }
snippet eas-
	each_slice(${1:2}) { |${2:group}| ${3} }
snippet eav
	each_value { |${1:val}| ${2} }
snippet eawi
	each_with_index { |${1:e}, ${2:i}| ${3} }
snippet reve
	reverse_each { |${1:e}| ${2} }
snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet map
	map { |${1:e}| ${2} }
snippet mapwi-
	enum_with_index.map { |${1:e}, ${2:i}| ${3} }
snippet sor
	sort { |a, b| ${1} }
snippet sorb
	sort_by { |${1:e}| ${2} }
snippet ran
	sort_by { rand }
snippet all
	all? { |${1:e}| ${2} }
snippet any
	any? { |${1:e}| ${2} }
snippet cl
	classify { |${1:e}| ${2} }
snippet col
	collect { |${1:e}| ${2} }
snippet det
	detect { |${1:e}| ${2} }
snippet fet
	fetch(${1:name}) { |${2:key}| ${3} }
snippet fin
	find { |${1:e}| ${2} }
snippet fina
	find(:all, ${1:conditions =>} ${2})
snippet gre
	grep(${1:/pattern/}) { |${2:match}| ${3} }
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${4} }
snippet sca
	scan(${1:/pattern/}) { |${2:match}| ${3} }
snippet max
	max { |a, b|, ${1} }
snippet min
	min { |a, b|, ${1} }
snippet par
	partition { |${1:e}|, ${2} }
snippet rej
	reject { |${1:e}|, ${2} }
snippet sel
	select { |${1:e}|, ${2} }
snippet lam
	lambda { |${1:args}| ${2} }
snippet do
	do |${1:variable}|
		${2}
	end
snippet :
	:${1:key} => ${2:"value"}${3}
snippet ope
	open(${1:"path/or/url/or/pipe"}, "${2:w}") { |${3:io}| ${4} }
# path_from_here()
snippet patfh
	File.join(File.dirname(__FILE__), *%2[${1:rel path here}])${2}
# unix_filter {}
snippet unif
	ARGF.each_line${1} do |${2:line}|
		${3}
	end
# option_parse {}
snippet optp
	require "optparse"

	options = {${1:default => "args"}}

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}
snippet opt
	opts.on( "-${1:o}", "--${2:long-option-name}", ${3:String},
	         "${4:Option description.}") do |${5:opt}|
		${6}
	end
snippet tc
	require "test/unit"

	require "${1:library_file_name}"

	class Test${2:$1} < Test::Unit::TestCase
		def test_${3:case_name}
			${4}
		end
	end
snippet ts
	require "test/unit"

	require "tc_${1:test_case_file}"
	require "tc_${2:test_case_file}"${3}
snippet as
	assert(${1:test}, "${2:Failure message.}")${3}
snippet ase
	assert_equal(${1:expected}, ${2:actual})${3}
snippet asne
	assert_not_equal(${1:unexpected}, ${2:actual})${3}
snippet asid
	assert_in_delta(${1:expected_float}, ${2:actual_float}, ${3:2 ** -20})${4}
snippet asio
	assert_instance_of(${1:ExpectedClass}, ${2:actual_instance})${3}
snippet asko
	assert_kind_of(${1:ExpectedKind}, ${2:actual_instance})${3}
snippet asn
	assert_nil(${1:instance})${2}
snippet asnn
	assert_not_nil(${1:instance})${2}
snippet asm
	assert_match(/${1:expected_pattern}/, ${2:actual_string})${3}
snippet asnm
	assert_no_match(/${1:unexpected_pattern}/, ${2:actual_string})${3}
snippet aso
	assert_operator(${1:left}, :${2:operator}, ${3:right})${4}
snippet asr
	assert_raise(${1:Exception}) { ${2} }
snippet asnr
	assert_nothing_raised(${1:Exception}) { ${2} }
snippet asrt
	assert_respond_to(${1:object}, :${2:method})${3}
snippet ass assert_same(..)
	assert_same(${1:expected}, ${2:actual})${3}
snippet ass assert_send(..)
	assert_send([${1:object}, :${2:message}, ${3:args}])${4}
snippet asns
	assert_not_same(${1:unexpected}, ${2:actual})${3}
snippet ast
	assert_throws(:${1:expected}) { ${2} }
snippet asnt
	assert_nothing_thrown { ${1} }
snippet fl
	flunk("${1:Failure message.}")${2}
# Benchmark.bmbm do .. end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${2}
	end
snippet rep
	results.report("${1:name}:") { TESTS.times { ${2} }}
# Marshal.dump(.., file)
snippet Md
	File.open(${1:"path/to/file.dump"}, "wb") { |${2:file}| Marshal.dump(${3:obj}, $2) }${4}
# Mashal.load(obj)
snippet Ml
	File.open(${1:"path/to/file.dump"}, "rb") { |${2:file}| Marshal.load($2) }${3}
# deep_copy(..)
snippet deec
	Marshal.load(Marshal.dump(${1:obj_to_copy}))${2}
snippet Pn-
	PStore.new(${1:"file_name.pstore"})${2}
snippet tra
	transaction(${1:true}) { ${2} }
# xmlread(..)
snippet xml-
	REXML::Document.new(File.read(${1:"path/to/file"}))${2}
# xpath(..) { .. }
snippet xpa
	elements.each(${1:"//Xpath"}) do |${2:node}|
		${3}
	end
# class_from_name()
snippet clafn
	split("::").inject(Object) { |par, const| par.const_get(const) }
# singleton_class()
snippet sinc
	class << self; self end
snippet nam
	namespace :${1:`Filename()`} do
		${2}
	end
snippet tas
		desc "${1:Task description\}"
	task :${2:task_name => [:dependent, :tasks]} do
		${3}
	end

snippet :
	:${1} => ${2}

#rails snippets

snippet wants
	wants.<+js|xml|html+> <+{ <++> }+>
snippet crw
	cattr_accessor :${1:attr_names}
snippet tcb
	t.boolean :${1:title}
	${2}
snippet mrmc
	remove_column :${1:table}, :${2:column}
snippet pa
	params[:${1:id}]${2}
snippet nc
	named_scope :<+name+><+, :joins => :<+table+>+>, :conditions => <+['<+<+field+> = ?+>', <+true+>]+>
snippet rl
	render :layout => "${1:layoutname}"
snippet logd
	logger.debug { "${1:message}" }${2}
snippet ril
	render :inline => "${1:<%= 'hello' %>}", :locals => { ${2::name} => "${3:value}"${4} }
snippet rit
	render :inline => "${1:<%= 'hello' %>}", :type => ${2::rxml}
snippet bf
	before_filter :${1:method}
snippet asre
	assert_response :${1:success}, @response.body${2}
snippet mccc
	t.column :${1:title}, :${2:string}
snippet tcda
	t.date :${1:title}
	${2}
snippet xput
	xhr :put, :${1:update}, :id => ${2:1}, :${3:object} => { ${4} }${5}
snippet tctss
	t.timestamps
	${1}
snippet tcl
	t.integer :lock_version, :null => false, :default => 0
	${1}
snippet rn
	render :nothing => ${1:true}
snippet mct
	create_table :${1:table_name} do |t|
	t.column :${2:name}, :${3:type}
	end
snippet flash
	flash[:${1:notice}] = "${2}"
snippet ist
	<%= image_submit_tag("<+agree.png+>"<+<+, :id => "<+id+>"+><+, :name => "<+name+>"+><+, :class => "<+class+>"+><+, :disabled => <+false+>+>+>) %>
snippet rps
	render :partial => "${1:item}", :status => ${2:500}
snippet mrc
	remove_column :${1:column}
snippet mapr
	${1:map}.resource :${2:resource}
snippet tcs
	t.string :${1:title}
	${2}
snippet defnew
	def new
	@${1:model_class_name} = ${2:ModelClassName}.new

		respond_to do |wants|
			wants.html # new.html.erb
			wants.xml  { render :xml => @$1 }
		end
	end${3}
snippet fina
	find(:all<+, :conditions => ['<+<+field+> = ?+>', <+true+>]+>)
snippet tch
	t.change :<+name+><+, :<+string+><+, :<+limit+> => <+80+>+>+>
snippet ass
	assert_select '<+path+>'<+, :<+text+> => <+'<+inner_html+>'+>+> <+do<++>+>
snippet logw
	logger.warn { "${1:message}" }${2}
snippet habtm
	has_and_belongs_to_many :${1:object}, :join_table => "${2:table_name}", :foreign_key => "${3}_id"${4}
snippet finf
	find(:first<+, :conditions => ['<+<+field+> = ?+>', <+true+>]+>)
snippet vi
	validates_inclusion_of :${1:attribute}, :in => ${2:%w( mov avi )}, :on => :${3:create}
snippet defshow
	def show
	@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |wants|
			wants.html # show.html.erb
			wants.xml  { render :xml => @$1 }
		end
	end${3}
snippet mapca
	${1:map}.catch_all "*${2:anything}", :controller => "${3:default}", :action => "${4:error}"${5}
snippet migration
	class ${1:`Snippet_MigrationNameFromFilename()`} < ActiveRecord::Migration
		def self.up
			${2}
		end

		def self.down
		end
	end
snippet mcht
	change_table :${1:table_name} do |t|
		${2}
	end
snippet artnp
	assert_redirected_to 
snippet vl
	validates_length_of :${1:attribute}, :within =>${2}, :message => "${3}"
snippet tcd
	t.decimal :<+title+><+<+, :precision => <+10+>+><+, :scale => <+2+>+>+>
snippet defdestroy
	def destroy
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
		@$1.destroy

		respond_to do |wants|
			wants.html { redirect_to($1s_url) }
			wants.xml  { head :ok }
		end
	end${3}
snippet maprs
	${1:map}.resources :${2:resource}
snippet tre
	t.rename :<+old_column_name+>, :<+new_column_name+>
snippet artnpp
	assert_redirected_to <+<+parent+>_<+child+>_path(<+@<+parent+>+>)+>
snippet sha1
	Digest::SHA1.hexdigest(${1:string})
snippet tcbi
	t.binary :<+title+><+, :limit => <+2+>.megabytes+>
snippet tcf
	t.float :${1:title}
	${2}
snippet asrj
	assert_rjs :${1:replace}
snippet rpc
		render :partial => "${1:item}", :collection => @${2:item}
snippet vc
	validates_confirmation_of :${1:attribute}, :message => "${2}"
snippet mrw
	mattr_accessor :${1:attr_names}
snippet mcc
	change_column :${1:table}, :${2:column}, :${3:type}
snippet rpl
		render :partial => "${1:item}", :locals => { :${2:item} => @${3:item} }
snippet xget
	xhr :get, :${1}
snippet log
	RAILS_DEFAULT_LOGGER.${1:debug} ${2}
snippet rtlt
	render :text => "${1:text to render}", :layout => ${2:true}
snippet rp
	render :partial => "${1:item}"
snippet defupdate
	def update
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])

		respond_to do |wants|
			if @$1.update_attributes(params[:$1])
				flash[:notice] = '$2 was successfully updated.'
				wants.html { redirect_to(@$1) }
				wants.xml  { head :ok }
			else
				wants.html { render :action => "edit" }
				wants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }
			end
		end
	end${3}
snippet rfu
	render :file => "${1:filepath}", :use_full_path => ${2:false}
snippet asnd
	assert_no_difference "${1:Model}.${2:count}" do
		${3}
	end
snippet vn
		validates_numericality_of :${1:attrib}
snippet mcol
	remove_column :${1:table}, :${2:column}
snippet asd
	assert_difference "${1:Model}.${2:count}", $1 do
		${3}
	end
snippet rjson
	render :json => ${1:text to render}
snippet fini
	find(<+id+>)
snippet mapc
	${1:map}.${2:connect} '${3:controller/:action/:id}'
snippet vao
	validates_acceptance_of :${1:terms}, :accept => "${2}", :message => "${3}"
snippet tcdt
	t.datetime :${1:title}
	${2}
snippet rxml
	render :xml => ${1:text to render}
snippet logf
	logger.fatal { "${1:message}" }${2}
snippet tct
	t.text :${1:title}
	${2}
snippet va
	validates_associated :${1:attribute}
snippet ri
	render :inline => "${1}"

snippet logi
	logger.info { "${1:message}" }${2}
snippet mp
	map(&:${1:id})
snippet hmt
	has_many :<+association_name+>, :through => :<+join_association+><+, :source => '<++>'+>
snippet ncl
	named_scope :<+name+>, lambda { |<+param+>| { :conditions => <+['<+<+field+> = ?+>', <+param+>]+> } }
snippet i18
	I18n.t('${1:type.key}')${2}
snippet hm
	has_many :${1:object}, :class_name => ${object}"
snippet artpp
	assert_redirected_to <+<+model+>s_path+>
snippet ral
	render :action => "${1:action}", :layout => "${2:layoutname}"
snippet rest
	respond_to do |wants|
		wants.${1:html} <+{ <++> }+>
	end
snippet tcti
	t.time :${1:title}
	${2}
snippet tcts
	t.timestamp :${1:title}
	${2}
snippet rns
	render :nothing => ${1:true}, :status => ${2:401}
snippet loge
	logger.error { "${1:message}" }${2}
snippet ru
	render :update do |${1:page}|
		$1.${2}
	end
snippet xdelete
	xhr :delete, :${1:destroy}, :id => ${2:1}${3}
snippet rf
	render :file => "${1:filepath}"
snippet mrnc
	rename_column :${1:table}, :${2:old}, :${3:new}
snippet bt
	belongs_to :${1:association}
snippet tref
	t.references :${1:model}
snippet vu
	validates_uniqueness_of :${1}, :on => :${2:"createmk"}, :message => "<+must be unique+>"+>
snippet sweeper
	class ${1:ModelClassName}Sweeper < ActionController::Caching::Sweeper
		observe $1

		def after_save(${2:model_class_name})
			expire_cache($2)
		end

		def after_destroy($2)
			expire_cache($2)
		end

		def expire_cache($2)
			expire_page
		end
	end
snippet rtl
	render :text => "${1:text to render}", :layout => "${2:layoutname}"
snippet ho
	has_one :${1:object}, :class_name => "${2:Class}", :foreign_key => "${3:class}_id"
snippet defedit
	def edit
		@${1:model_class_name} = ${2:ModelClassName}.find(params[:id])
	end
snippet xpost
	xhr :post, :${1:create}, :${2:object} => { ${3} }
snippet trc
	t.remove :${1:column}
snippet mac
	add_column :${1:table}, :${2:column}, :${3:type}
snippet ra
	render :action => "${1:action}"
snippet art
	assert_redirected_to ${1::action => "${2:index}"}
snippet ve
	validates_exclusion_of :<+attribute+><+, :in => <+%w( <+mov avi+> )+>, :on => :<+create+>, :message => "<+extension %s is not allowed+>"+>
snippet hmd
	has_many :<+object+>s<+, :class_name => "<+object+>", :foreign_key => "<+reference+>_id"+>, :dependent => :destroy<++>
snippet tcr
	t.references :<+taggable+><+, :polymorphic => <+{ :default => '<+Photo+>' }+>+>
snippet artp
	assert_redirected_to <+<+model+>_path(<+@<+model+>+>)+>
snippet rt
	render :text => "${1:text to render}"
snippet defindex
	def index
		@${1:model_class_name} = ${2:ModelClassName}.all

		respond_to do |wants|
			wants.html # index.html.erb
			wants.xml  { render :xml => @$1s }
		end
	end${3}
snippet mapwo
	${1:map}.with_options :${2:controller} => '${3:thing}' do |$3|
		${4}
	end
snippet rpo
	render :partial => "<+item+>", :object => <+@<+item+>+>
snippet tci
	t.integer :${1:title}
	${2}
snippet vf
	validates_format_of :${1:attribute}, :with => /${2:regex}/<+, :on => :<+create+>, :message => "<+is invalid+>"+>
snippet mbs
	before_save :${1:method}
snippet vpo
	validates_presence_of :${1:attribute}
snippet finl
	find(:last<+, :conditions => ['<+<+field+> = ?+>', <+true+>]+>)
snippet rts
	render :text => "${1:text to render}", :status => ${2:401}
snippet defcreate
	def create
		@${1:model_class_name} = ${2:ModelClassName}.new(params[:$1])

		respond_to do |wants|
			if @$1.save
				flash[:notice] = '$2 was successfully created.'
				wants.html { redirect_to(@$1) }
				wants.xml  { render :xml => @$1, :status => :created, :location => @$1 }
			else
				wants.html { render :action => "new" }
				wants.xml  { render :xml => @$1.errors, :status => :unprocessable_entity }
			end
		end
	end${3}

#rails rjs
snippet rep
	page.replace <+"<+id+>"+>, :<+partial => "<+template+>"+>
snippet ins
	page.insert_html :<+top+>, <+"<+id+>"+>, :<+partial => "<+template+>"+>
snippet tog
	page.toggle <+"<+id(s)+>"+>
snippet reph
	page.replace_html <+"<+id+>"+>, :<+partial => "<+template+>"+>
snippet vis
	page.visual_effect :<+toggle_slide+>, <+"<+DOM ID+>"+>
snippet hide
	page.hide <+"<+id(s)+>"+>
snippet show
	page.show <+"<+id(s)+>"+>

#eruby rails
snippet ff
	<% form_for @${1:model} do |f| -%>
		${2}
	<% end -%>
snippet ffrb
	<%= ${1:f}.radio_button :${2:attribute}, :${3:tag_value} %>
snippet ffe
	<% error_messages_for :${1:model} -%>

	<% form_for @${2:model} do |f| -%>
		${3}
	<% end -%>
snippet liai
	<%= link_to "<+link text+>", :action => "<+edit+>", :id => <+@<+item+>+> %>
snippet ffl
	<%= ${1:f}.label :${2:attribute}, '${3:$2}' %>
snippet ffs
	<%= ${1:f}.submit "${2:submit}" %>
snippet fields
	<% fields_for :${1:model}, @$1 do |${2:f}| -%>
		${3}
	<% end -%>
snippet ffta
	<%= ${1:f}.text_area :${2:attribute} %>
snippet lip
	<%= link_to <+"<+link text+>"+>, <+<+model+>_path(<+@+><+instance+>)+> %>
snippet ct
	<%= content_tag '${1:DIV}', ${2:content}${3:,options} -%>
snippet sslt
	<%= stylesheet_link_tag "${1}" %>
snippet ffpf
	<%= ${1:f}.password_field :${2:attribute} %>
snippet jsit
	<%= javascript_include_tag "${1}" %>
snippet end
	<% end -%>
snippet lica
	<%= link_to "${1:link text}", :controller => "${2:items}", :action => "${3:index}" %>
snippet linpp
	<%= link_to <+"<+link text+>"+>, <+<+parent+>_<+child+>_path(<+@+><+parent+>)+> %>
snippet rp
	<%= render :partial => "${1:file}"${2} %>
snippet ffcb
	<%= ${1:f}.check_box :${2:attribute} %>
snippet lia
	<%= link_to "${1:link text}", :action => "${2:index}" %>
snippet fftf
	<%= ${1:f}.text_field :${2:attribute} %>
snippet ffhf
	<%= ${1:f}.hidden_field :${2:attribute} %>
snippet for
	<% for ${2:item} in ${1:list} -%>
		${3}
	<% end -%>
snippet it
	<%= image_tag "${1}"${2} %>
snippet lic
	<%= link_to "${1:link text}", :controller => "${2:items}" %>
snippet ft
	<% form_tag(<+:action => "<+update+>"+><+, {:<+class+> => "<+form+>"}+>) do -%>
		<++>
	<% end -%>
snippet i18
	I18n.t('${1:type.key}')${2}
snippet rf
	<%= render :file => "${1:file}"${2} %>
snippet jit
	<%= javascript_include_tag <+:all+><+, :cache => <+true+>+> %>
snippet ffff
	<%= ${1:f}.file_field :${2:attribute} %>
snippet lim
	<%= link_to <+model+>.<+name+>, <+<+model+>_path(<+model+>)+> %>
snippet slt
	<%= stylesheet_link_tag <+:all+><+, :cache => <+true+>+> %>
snippet linp
	<%= link_to <+"<+link text+>"+>, <+<+parent+>_<+child+>_path(<+@+><+parent+>, <+@+><+child+>)+> %>
snippet licai
	<%= link_to "<+link text+>", :controller => "<+items+>", :action => "<+edit+>", :id => <+@<+item+>+> %>
snippet lipp
	<%= link_to <+"<+link text+>"+>, <+<+model+>s_path+> %>
snippet rt
	<%= render :template => "${1:file}"${2} %>
snippet conf
	<% content_for :${1:yield_label_in_layout} do -%>
		${2}
	<% end -%>
snippet cs
	<%= collection_select <+object+>, <+method+>, <+collection+>, <+value_method+>, <+text_method+><+, <+[options]+>, <+[html_options]+>+> %>
snippet ofcfs
	<%= options_from_collection_for_select <+collection+>, <+value_method+>, <+text_method+><+, <+[selected_value]+>+> %>
snippet st
	<%= submit_tag "<+Save changes+>"<+, :id => "<+submit+>"+><+, :name => "<+submit+>"+><+, :class => "<+form_name+>"+><+, :disabled => <+false+>+><+, :disable_with => "<+Please wait+>"+> %>
snippet lt
	<%= link_to "${1:name}", ${2:dest} %>
